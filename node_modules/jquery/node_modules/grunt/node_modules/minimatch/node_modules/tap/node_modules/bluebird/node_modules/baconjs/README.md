Bacon.js
========

<img src="https://raw.github.com/baconjs/bacon.js/master/logo.png" align="right" width="300px" />

A small functional reactive programming lib for JavaScript.

Turns your event spaghetti into clean and declarative feng shui bacon, by switching
from imperative to functional. It's like replacing nested for-loops with functional programming
concepts like [`map`](#observable-map) and [`filter`](#observable-filter). Stop working on individual events and work with event streams instead.
Combine your data with [`merge`](#stream-merge) and [`combine`](#observable-combine).
Then switch to the heavier weapons and wield [`flatMap`](#observable-flatmap) and [`combineTemplate`](#bacon-combinetemplate) like a boss.

It's the `_` of Events. Too bad the symbol `~` is not allowed in JavaScript.

Here's the stuff.

- [Homepage](http://baconjs.github.io/)
- [Source files](https://github.com/baconjs/bacon.js/tree/master/src)
- [Generated javascript](https://github.com/baconjs/bacon.js/blob/master/dist/)
- [Specs](https://github.com/baconjs/bacon.js/blob/master/spec/specs/main.coffee)
- [Examples](https://github.com/baconjs/bacon.js/blob/master/examples/examples.html)
- [Wiki](https://github.com/baconjs/bacon.js/wiki/) with more docs, related projects and more
- [Cheat Sheet](http://www.cheatography.com/proloser/cheat-sheets/bacon-js/)
- [My Blog](http://nullzzz.blogspot.com) with some baconful and reactive postings along with a Bacon.js tutorial
- [Bacon.js Blog](http://baconjs.blogspot.com)
- [Bacon.js Google Group](https://groups.google.com/forum/#!forum/baconjs) for discussion and questions
- [TodoMVC with Bacon.js and jQuery](https://github.com/raimohanska/todomvc/blob/bacon-jquery/labs/architecture-examples/baconjs/js/app.js)
- [Stack Overflow](http://stackoverflow.com/questions/tagged/bacon.js) for well-formed questions. Use the "bacon.js" tag.
- [Gitter](https://gitter.im/baconjs/bacon.js) chat for developers of Bacon.

You can also check out my entertaining (LOL), interactive, solid-ass [slideshow](http://raimohanska.github.com/bacon.js-slides/).

And remember to give me feedback on the bacon! Let me know if you've
used it. Tell me how it worked for you. What's missing? What's wrong?
Please contribute!

[![Build Status](https://travis-ci.org/baconjs/bacon.js.svg?branch=master)](https://travis-ci.org/baconjs/bacon.js)
[![NPM version](http://img.shields.io/npm/v/baconjs.svg)](https://www.npmjs.org/package/baconjs)
[![NuGet version](http://img.shields.io/nuget/v/Bacon.js.svg)](https://www.nuget.org/packages/Bacon.js)
[![Dependency Status](https://david-dm.org/baconjs/bacon.js.svg)](https://david-dm.org/baconjs/bacon.js)
[![devDependency Status](https://david-dm.org/baconjs/bacon.js/dev-status.svg)](https://david-dm.org/baconjs/bacon.js#info=devDependencies)

Table of contents
=================

- [Bacon.js](#baconjs)
- [Table of contents](#table-of-contents)
- [Install](#install)
- [Intro](#intro)
- [API](#api)
    - [Creating streams](#creating-streams)
    - [Bacon.fromBinder for custom streams](#baconfrombinder-for-custom-streams)
    - [Common methods in EventStreams and Properties](#common-methods-in-eventstreams-and-properties)
    - [EventStream](#eventstream)
    - [Property](#property)
    - [Combining multiple streams and properties](#combining-multiple-streams-and-properties)
    - [Function Construction rules](#function-construction-rules)
    - [Lazy evaluation](#lazy-evaluation)
    - [Latest value of Property or EventStream](#latest-value-of-property-or-eventstream)
    - [Bus](#bus)
    - [Event](#event)
        - [Event properties and methods](#event-properties-and-methods)
    - [Errors](#errors)
    - [Join Patterns](#join-patterns)
        - [Join patterns as a "chemical machine"](#join-patterns-as-a-chemical-machine)
        - [Join patterns and properties](#join-patterns-and-properties)
        - [Join patterns and Bacon.bus](#join-patterns-and-baconbus)
    - [Cleaning up](#cleaning-up)
    - [EventStream and Property semantics](#eventstream-and-property-semantics)
    - [Atomic updates](#atomic-updates)
    - [For RxJs Users](#for-rxjs-users)
- [Examples](#examples)
- [Build](#build)
- [Test](#test)
- [Dependencies](#dependencies)
- [Compatibility with other libs](#compatibility-with-other-libs)
- [Compatibility with browsers](#compatibility-with-browsers)
- [Node.js](#nodejs)
- [AMD](#amd)
- [Why Bacon?](#why-bacon)
- [Contribute](#contribute)
- [Sponsors](#sponsors)


Install
=======

If you're targeting to [node.js](http://nodejs.org/), you can

    npm install baconjs

For [bower](https://github.com/twitter/bower) users:

    bower install bacon

Both minified and unminified versions available on [cdnjs](https://cdnjs.com/libraries/bacon.js).

Starting from 0.7.45, you can build your own Bacon.js bundle with selected features
only. See instructions [here](#build).

Prefer to drink from the firehose? Download from Github [master](https://raw.github.com/baconjs/bacon.js/master/dist/Bacon.js).

Visual Studio users can obtain version 0.7.76 via NuGet Packages
    https://www.nuget.org/packages/Bacon.js/0.7.76


Intro
=====

The idea of Functional Reactive Programming is quite well described by Conal Elliot at [Stack Overflow](http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631).

Bacon.js is a library for functional reactive programming. Or let's say it's a library for
working with [events](#event) and dynamic values (which are called [Properties](#property) in Bacon.js).

Anyways, you can wrap an event source,
say "mouse clicks on an element" into an [`EventStream`](#eventstream) by saying

```js
var clicks = $("h1").asEventStream("click")
```

Each EventStream represents a stream of events. It is an Observable object, meaning
that you can listen to events in the stream using, for instance, the [`onValue`](#stream-onvalue) method
with a callback. Like this:

```js
clicks.onValue(function() { alert("you clicked the h1 element") })
```

But you can do neater stuff too. The Bacon of bacon.js is in that you can transform,
filter and combine these streams in a multitude of ways (see API below). The methods [`map`](#observable-map),
[`filter`](#observable-filter), for example, are similar to same functions in functional list programming
(like [Underscore](http://underscorejs.org/)). So, if you say

```js
var plus = $("#plus").asEventStream("click").map(1)
var minus = $("#minus").asEventStream("click").map(-1)
var both = plus.merge(minus)
```

.. you'll have a stream that will output the number 1 when the "plus" button is clicked
and another stream outputting -1 when the "minus" button is clicked. The `both` stream will
be a merged stream containing events from both the plus and minus streams. This allows
you to subscribe to both streams with one handler:

```js
both.onValue(function(val) { /* val will be 1 or -1 */ })
```

In addition to EventStreams, bacon.js has a thing called [`Property`](#property), that is almost like an
EventStream, but has a "current value". So things that change and have a current state are
Properties, while things that consist of discrete events are EventStreams. You could think
mouse clicks as an EventStream and mouse position as a Property. You can create Properties from
an EventStream with [`scan`](#observable-scan) or [`toProperty`](#stream-toproperty) methods. So, let's say

```js
function add(x, y) { return x + y }
var counter = both.scan(0, add)
counter.onValue(function(sum) { $("#sum").text(sum) })
```

The `counter` property will contain the sum of the values in the `both` stream, so it's practically
a counter that can be increased and decreased using the plus and minus buttons. The [`scan`](#observable-scan) method
was used here to calculate the "current sum" of events in the `both` stream, by giving a "seed value"
`0` and an "accumulator function" `add`. The scan method creates a property that starts with the given
seed value and on each event in the source stream applies the accumulator function to the current
property value and the new value from the stream.

Properties can be very conveniently used for assigning values and attributes to DOM elements with JQuery.
Here we assign the value of a property as the text of a span element whenever it changes:

```js
property.assign($("span"), "text")
```

Hiding and showing the same span depending on the content of the property value is equally straightforward

```js
function hiddenForEmptyValue(value) { return value == "" ? "hidden" : "visible" }
property.map(hiddenForEmptyValue).assign($("span"), "css", "visibility")
```

In the example above a property value of "hello" would be mapped to "visible", which in turn would result in Bacon calling

```js
$("span").css("visibility", "visible")
```

For an actual tutorial, please check out my [blog posts](http://nullzzz.blogspot.fi/2012/11/baconjs-tutorial-part-i-hacking-with.html)

API
===

Creating streams
----------------

<a name="$-aseventstream"></a>
[`$.asEventStream(eventName)`](#$-aseventstream "$.asEventStream(eventName : String)") creates an EventStream from events on a
jQuery or Zepto.js object. You can pass optional arguments to add a
jQuery live selector and/or a function that processes the jQuery
event and its parameters, if given, like this:

```js
$("#my-div").asEventStream("click", ".more-specific-selector")
$("#my-div").asEventStream("click", ".more-specific-selector", function(event, args) { return args[0] })
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

<a name="bacon-frompromise"></a>
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [, abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. ´fromPromise(p, true)´ to have the `abort` method of the given promise be called when all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into `[new Bacon.Next(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

<a name="bacon-fromevent"></a>
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.

```js
Bacon.fromEvent(document.body, "click").onValue(function() { alert("Bacon!") })
```

<a name="bacon-fromcallback"></a>
[`Bacon.fromCallback(f [, args...])`](#bacon-fromcallback "Bacon.fromCallback(f : (A -> void) -> void [, args...]) : EventStream[A]") creates an EventStream from a function that
accepts a callback. The function is supposed to call its callback just
once. For example:

```js
Bacon.fromCallback(function(callback) {
  setTimeout(function() {
    callback("Bacon!")
  }, 1000)
})
```

This would create a stream that outputs a single value "Bacon!" and ends
after that. The use of setTimeout causes the value to be delayed by 1
second.

You can also give any number of arguments to [`fromCallback`](#bacon-fromcallback), which will be
passed to the function. These arguments can be simple variables, Bacon
EventStreams or Properties. For example the following will output "Bacon rules":

```js
bacon = Bacon.constant('bacon')
Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').log();
```

<a name="bacon-fromcallback-object"></a>
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [, args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.

<a name="bacon-fromnodecallback"></a>
[`Bacon.fromNodeCallback(f [, args...])`](#bacon-fromnodecallback "Bacon.fromNodeCallback(f : (E -> A -> void) -> void [, args...]) : EventStream[A]") behaves the same way as [`Bacon.fromCallback`](#bacon-fromcallback),
except that it expects the callback to be called in the Node.js convention:
`callback(error, data)`, where error is null if everything is fine. For example:

```js
var Bacon = require('baconjs').Bacon,
    fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
read.onError(function(error) { console.log("Reading failed: " + error); });
read.onValue(function(value) { console.log("Read contents: " + value); });
```

<a name="bacon-fromnodecallback-object"></a>
[`Bacon.fromNodeCallback(object, methodName [, args...])`](#bacon-fromnodecallback-object "Bacon.fromNodeCallback(object, methodName [, args...])") a variant of fromNodeCallback which calls the named method of a given object.

<a name="bacon-frompoll"></a>
[`Bacon.fromPoll(interval, f)`](#bacon-frompoll "Bacon.fromPoll(interval : Number, f : -> Event[A]) : EventStream[A]") polls given function with given interval.
Function should return Events: either [`Bacon.Next`](#bacon-next) or [`Bacon.End`](#bacon-end). Polling occurs only
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

<a name="bacon-once"></a>
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.Error("fail"))`.

<a name="bacon-fromarray"></a>
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])

<a name="bacon-interval"></a>
[`Bacon.interval(interval, value)`](#bacon-interval "Bacon.interval(interval : Number, value : A) : EventStream[A]") repeats the single element
indefinitely with the given interval (in milliseconds)

<a name="bacon-sequentially"></a>
[`Bacon.sequentially(interval, values)`](#bacon-sequentially "Bacon.sequentially(interval : Number, values : Array[A]) : EventStream[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

<a name="bacon-repeatedly"></a>
[`Bacon.repeatedly(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval : Number, values : Array[A]) : EventStream[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.

<a name="bacon-repeat"></a>
[`Bacon.repeat(fn)`](#bacon-repeat "Bacon.repeat(fn: Number -> Observable[A]): EventStream[A]") Calls generator function which is expected to return an observable. The returned EventStream contains
values and errors from the spawned observable. When the spawned observable ends, the generator is called
again to spawn a new observable.

This is repeated until the generator returns a falsy value
(such as `undefined` or `false`).

The generator function is called with one argument — iteration number starting from `0`.

Here's an example:

```js
Bacon.repeat(function(i) {
  if (i < 3) {
    return Bacon.once(i);
  } else {
    return false;
  }
}).log()
```

The example will produce values 0, 1 and 2.

<a name="bacon-never"></a>
[`Bacon.never()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream that immediately ends.

<a name="bacon-later"></a>
[`Bacon.later(delay, value)`](#bacon-later "Bacon.later(delay : Number, value : A) : EventStream[A]") creates a single-element stream that
produces given value after given delay (milliseconds).

<a name="new-bacon-eventstream"></a>
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

<a name="property-toeventstream"></a>
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.

[`new Bacon.Bus()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus) section below)

Pro tip: you can also put Errors into streams created with the
constructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain
value.

Bacon.fromBinder for custom streams
-----------------------------------

If none of the factory methods above apply, you may of course roll your own EventStream by using [`Bacon.fromBinder`](#bacon-frombinder).

<a name="bacon-frombinder"></a>
[`Bacon.fromBinder(subscribe)`](#bacon-frombinder "Bacon.fromBinder(subscribe)") The parameter `subscribe` is a function that accepts a `sink` which is a function that your `subscribe` function can "push" events to.

For example:

```js
var stream = Bacon.fromBinder(function(sink) {
  sink("first value")
  sink([new Bacon.Next("2nd"), new Bacon.Next("3rd")])
  sink(new Bacon.Next(function() {
    return "This one will be evaluated lazily"
  }))
  sink(new Bacon.Error("oops, an error"))
  sink(new Bacon.End())
  return function() {
     // unsub functionality here, this one's a no-op
  }
})
stream.log()
```

As shown in the example, you can push

- A plain value, like `"first value"`
- An [`Event`](#event) object including [`Bacon.Error`](#bacon-error) (wraps an error) and [`Bacon.End`](#bacon-end) (indicates
stream end).
- An array of event objects at once

Other examples can be found on [JSFiddle](http://jsfiddle.net/PG4c4/) and the
[Bacon.js blog](http://baconjs.blogspot.fi/2013/12/wrapping-things-in-bacon.html).

The `subscribe` function must return a function. Let's call that function
`unsubscribe`. The returned function can be used by the subscriber (directly or indirectly) to
unsubscribe from the EventStream. It should release all resources that the subscribe function reserved.

The `sink` function may return [`Bacon.noMore`](#bacon-nomore) (as well as [`Bacon.more`](#bacon-more)
or any other value). If it returns [`Bacon.noMore`](#bacon-nomore), no further events will be consumed
by the subscriber. The `subscribe` function may choose to clean up all resources at this point (e.g.,
by calling `unsubscribe`). This is usually not necessary, because further calls to `sink` are ignored,
but doing so can increase performance in [rare cases](https://github.com/baconjs/bacon.js/issues/484).

The EventStream will wrap your `subscribe` function so that it will
only be called when the first stream listener is added, and the `unsubscribe`
function is called only after the last listener has been removed.
The subscribe-unsubscribe cycle may of course be repeated indefinitely,
so prepare for multiple calls to the subscribe function.

A note about the `new Bacon.Next(..)` constructor: You can use it like

```js
new Bacon.Next("value")
```

But the canonical way would be
```js
new Bacon.Next(function() { return "value"; })
```

The former version is safe only when you know that the actual value in
the stream is not a function.

The idea in using a function instead of a plain value is that the internals on Bacon.js take
advantage of [lazy evaluation](#lazy-evaluation) by deferring the evaluations of values
created by [`map`](#observable-map), [`combine`](#combining-multiple-streams-and-properties).

<a name="bacon-nomore"></a>
[`Bacon.noMore`](#bacon-nomore "Bacon.noMore") The opaque value `sink` function may return. See [`Bacon.fromBinder`](#bacon-frombinder).

<a name="bacon-more"></a>
[`Bacon.more`](#bacon-more "Bacon.more") The opaque value `sink` function may return. See [`Bacon.fromBinder`](#bacon-frombinder).

Common methods in EventStreams and Properties
---------------------------------------------

Both EventStream and Property share the Observable interface, and hence share a lot of methods.
Methods typically return observables so that methods can be chained; exceptions are noted.
Common methods are listed below.

<a name="observable-subscribe"></a>
[`observable.subscribe(f)`](#observable-subscribe "observable.subscribe(f)") subscribes given handler function to event stream. Function will receive Event objects (see below).
The subscribe() call returns a `unsubscribe` function that you can call to unsubscribe.
You can also unsubscribe by returning [`Bacon.noMore`](#bacon-nomore) from the handler function as a reply
to an Event.
`stream.subscribe` and `property.subscribe` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

<a name="observable-onvalue"></a>
[`observable.onValue(f)`](#observable-onvalue "observable.onValue(@ : Observable[A], f : A -> void) : Unsubscriber") subscribes a given handler function to the observable. Function will be called for each new value.
This is the simplest way to assign a side-effect to an observable. The difference
to the `subscribe` method is that the actual stream values are
received, instead of [`Event`](#event) objects.
The [Function Construction rules](#function-construction-rules) below apply here.
Just like `subscribe`, this method returns a function for unsubscribing.
`stream.onValue` and `property.onValue` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

<a name="observable-onvalues"></a>
[`observable.onValues(f)`](#observable-onvalues "observable.onValues(f)") like [`onValue`](#stream-onvalue), but splits the value (assuming its an
array) as function arguments to `f`.

<a name="observable-onerror"></a>
[`observable.onError(f)`](#observable-onerror "observable.onError(@ : Observable[A], f : Error -> void) : Unsubscriber") subscribes a callback to error events. The function will be called for each error in the stream.
Just like `subscribe`, this method returns a function for unsubscribing.

<a name="observable-onend"></a>
[`observable.onEnd(f)`](#observable-onend "observable.onEnd(f : -> void) : Unsubscriber") subscribes a callback to stream end. The function will be called when the stream ends.
Just like `subscribe`, this method returns a function for unsubscribing.

<a name="observable-topromise"></a>
[`observable.toPromise([PromiseCtr])`](#observable-topromise "observable.toPromise(@ : Observable[A] [, PromiseCtr]) : Promise[A]") returns a Promise which will be resolved with the last event coming from an Observable.
The global ES6 promise implementation will be used unless a promise constructor is given.
Use a shim if you need to support legacy browsers or platforms.
[caniuse promises](http://caniuse.com/#feat=promises).

<a name="observable-firsttopromise"></a>
[`observable.firstToPromise([PromiseCtr])`](#observable-firsttopromise "observable.firstToPromise(@ : Observable[A] [, PromiseCtr]) : Promise[A]") returns a Promise which will be resolved with the first event coming from an Observable.
Like [`toPromise`](#observable-topromise), the global ES6 promise implementation will be used unless a promise
constructor is given.

<a name="observable-map"></a>
[`observable.map(f)`](#observable-map "observable.map(@ : Observable[A], f : A -> B) : Observable[B]") maps values using given function, returning a new
stream/property. Instead of a function, you can also provide a constant
value. Further, you can use a property extractor string like
".keyCode". So, if f is a string starting with a
dot, the elements will be mapped to the corresponding field/function in the event
value. For instance map(".keyCode") will pluck the keyCode field from
the input values. If keyCode was a function, the result stream would
contain the values returned by the function.
The [Function Construction rules](#function-construction-rules) below apply here.
The [`map`](#observable-map) method, among many others, uses [lazy evaluation](#lazy-evaluation).

<a name="stream-map"></a>
[`stream.map(property)`](#stream-map "stream.map(property)") maps the stream events to the current value of
the given property. This is equivalent to [`property.sampledBy(stream)`](#property-sampledby).

<a name="observable-maperror"></a>
[`observable.mapError(f)`](#observable-maperror "observable.mapError(@ : Observable[A], f : E -> A) : Observable[A]") maps errors using given function. More
specifically, feeds the "error" field of the error event to the function
and produces a [`Next`](#bacon-next) event based on the return value.
The [Function Construction rules](#function-construction-rules) below apply here.
You can omit the argument to produce a [`Next`](#bacon-next) event with `undefined` value.

<a name="observable-errors"></a>
[`observable.errors()`](#observable-errors "observable.errors(@ : Observable[A]) : Observable[A]") returns a stream containing [`Error`](#bacon-error) events only.
Same as filtering with a function that always returns false.

<a name="observable-skiperrors"></a>
[`observable.skipErrors()`](#observable-skiperrors "observable.skipErrors(@ : Observable[A]) : Observable[A]") skips all errors.

<a name="observable-mapend"></a>
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -> Observable[A]) : Observable[A]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.

<a name="observable-filter"></a>
[`observable.filter(f)`](#observable-filter "observable.filter(@ : Observable[A], f : A -> Bool) : Observable[A]") filters values using given predicate function.
Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all) or a
property extractor string (like ".isValuable") instead. Just like with
[`map`](#observable-map), indeed.

<a name="observable-filter-property"></a>
[`observable.filter(property)`](#observable-filter-property "observable.filter(property)") filters values based on the value of a
property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true`
at the time of the event.

<a name="observable-skipduplicates"></a>
[`observable.skipDuplicates(isEqual)`](#observable-skipduplicates "observable.skipDuplicates([isEqual])") drops consecutive equal elements. So,
from `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality
checking by default. If the isEqual argument is supplied, checks by calling
isEqual(oldValue, newValue). For instance, to do a deep comparison,you can
use the isEqual function from [underscore.js](http://underscorejs.org/)
like `stream.skipDuplicates(_.isEqual)`.

<a name="observable-take"></a>
[`observable.take(n)`](#observable-take "observable.take(@ : Observable[A], n : Number) : Observable[A]") takes at most n values from the stream and then ends the stream. If the stream has
fewer than n values then it is unaffected.
Equal to [`Bacon.never()`](#bacon-never) if `n <= 0`.

<a name="observable-takeuntil"></a>
[`observable.takeUntil(stream)`](#observable-takeuntil "observable.takeUntil(@ : Observable[A], stream : EventStream[B]) : Observable[A]") takes elements from source until a Next event appears in the other stream.
If other stream ends without value, it is ignored.

<a name="observable-takewhile"></a>
[`observable.takeWhile(f)`](#observable-takewhile "observable.takeWhile(@ : Observable[A], f : A -> Bool) : Observable[A]") takes while given predicate function holds true, and then ends.
[Function Construction rules](#function-construction-rules) apply.

<a name="observable-takewhile-property"></a>
[`observable.takeWhile(property)`](#observable-takewhile-property "observable.takeWhile(property)") takes values while the value of a property holds true, and then ends.

<a name="observable-first"></a>
[`observable.first()`](#observable-first "observable.first(@ : Observable[A]) : Observable[A]") takes the first element from the stream. Essentially `observable.take(1)`.

<a name="observable-last"></a>
[`observable.last()`](#observable-last "observable.last(@ : Observable[A]) : Observable[A]") takes the last element from the stream. None, if stream is empty.

*Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.

<a name="observable-skip"></a>
[`observable.skip(n)`](#observable-skip "observable.skip(n)") skips the first n elements from the stream

<a name="observable-delay"></a>
[`observable.delay(delay)`](#observable-delay "observable.delay(delay)") delays the stream/property by given amount of milliseconds. Does not delay the initial value of a [`Property`](#property).

```js
var delayed = source.delay(2)
```

```
source:    asdf----asdf----
delayed:   --asdf----asdf--
```

<a name="observable-throttle"></a>
[`observable.throttle(delay)`](#observable-throttle "observable.throttle(delay)") throttles stream/property by given amount
of milliseconds. Events are emitted with the minimum interval of
[`delay`](#observable-delay). The implementation is based on [`stream.bufferWithTime`](#stream-bufferwithtime).
Does not affect emitting the initial value of a [`Property`](#property).

Example:

```js
var throttled = source.throttle(2)
```

```
source:    asdf----asdf----
throttled: --s--f----s--f--
```

<a name="observable-debounce"></a>
[`observable.debounce(delay)`](#observable-debounce "observable.debounce(delay)") throttles stream/property by given amount
of milliseconds, but so that event is only emitted after the given
"quiet period". Does not affect emitting the initial value of a Property.
The difference of [`throttle`](#observable-throttle) and [`debounce`](#observable-debounce) is the same as it is in the
same methods in jQuery.

Example:

```
source:             asdf----asdf----
source.debounce(2): -----f-------f--
```

<a name="observable-debounceimmediate"></a>
[`observable.debounceImmediate(delay)`](#observable-debounceimmediate "observable.debounceImmediate(delay)") passes the first event in the
stream through, but after that, only passes events after a given number
of milliseconds have passed since previous output.

Example:

```
source:                      asdf----asdf----
source.debounceImmediate(2): a-d-----a-d-----
```

<a name="observable-bufferingthrottle"></a>
[`observable.bufferingThrottle(minimumInterval)`](#observable-bufferingthrottle "observable.bufferingThrottle(@ : Observable[A], minimumInterval) : EventStream[A]") throttles the observable using a buffer so that at most one value event in minimumInteval is issued.
Unlike [`throttle`](#observable-throttle), it doesn't discard the excessive events but buffers them instead, outputting
them with a rate of at most one value per minimumInterval.

Example:

```js
var throttled = source.bufferingThrottle(2)
```

```
source:    asdf----asdf----
throttled: a-s-d-f-a-s-d-f-
```

<a name="observable-doaction"></a>
[`observable.doAction(f)`](#observable-doaction "observable.doAction(f)") returns a stream/property where the function f
is executed for each value, before dispatching to subscribers. This is
useful for debugging, but also for stuff like calling the
`preventDefault()` method for events. In fact, you can
also use a property-extractor string instead of a function, as in
`".preventDefault"`.

<a name="observable-doerror"></a>
[`observable.doError(f)`](#observable-doerror "observable.doError(f)") returns a stream/property where the function f
is executed for each error, before dispatching to subscribers.
That is, same as [`doAction`](#observable-doaction) but for errors.

<a name="observable-not"></a>
[`observable.not()`](#observable-not "observable.not(@ : Obserable[A]) : Observable[Bool]") returns a stream/property that inverts boolean values

<a name="observable-flatmap"></a>
[`observable.flatMap(f)`](#observable-flatmap "observable.flatMap(@ : Observable[A], f : A -> Observable[B] | Event[B] | B) : EventStream[B]") for each element in the source stream, spawn a new
stream using the function `f`. Collect events from each of the spawned
streams into the result [`EventStream`](#eventstream). Note that instead of a function, you can provide a
stream/property too. Also, the return value of function `f` can be either an
`Observable` (stream/property) or a constant value. The result of
[`flatMap`](#observable-flatmap) is always an [`EventStream`](#eventstream).

The [Function Construction rules](#function-construction-rules) below apply here.

`stream.flatMap()` can be used conveniently with [`Bacon.once()`](#bacon-once) and [`Bacon.never()`](#bacon-never) for converting and filtering at the same time, including only some of the results.

Example - converting strings to integers, skipping empty values:

```js
stream.flatMap(function(text) {
    return (text != "") ? parseInt(text) : Bacon.never()
})
```

<a name="observable-flatmaplatest"></a>
[`observable.flatMapLatest(f)`](#observable-flatmaplatest "observable.flatMapLatest(f)") like [`flatMap`](#observable-flatmap), but instead of including events from
all spawned streams, only includes them from the latest spawned stream.
You can think this as switching from stream to stream.
Note that instead of a function, you can provide a stream/property too.

The [Function Construction rules](#function-construction-rules) below apply here.

<a name="observable-flatmapfirst"></a>
[`observable.flatMapFirst(f)`](#observable-flatmapfirst "observable.flatMapFirst(f)") like [`flatMap`](#observable-flatmap), but only spawns a new
stream if the previously spawned stream has ended.

The [Function Construction rules](#function-construction-rules) below apply here.

<a name="observable-flatmaperror"></a>
[`observable.flatMapError(f)`](#observable-flatmaperror "observable.flatMapError(f)") like [`flatMap`](#observable-flatmap), but is applied only on [`Error`](#bacon-error) events. Returned values go into the
value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just
passed through, which can be implemented using flatMapError.

<a name="observable-flatmapwithconcurrencylimit"></a>
[`observable.flatMapWithConcurrencyLimit(limit, f)`](#observable-flatmapwithconcurrencylimit "observable.flatMapWithConcurrencyLimit(@ : Observable[A], limit : Number, f : A -> Observable[B] | Event[B] | B) : EventStream[B]") a super method of *flatMap* family. It limits the number of open spawned streams and buffers incoming events.
[`flatMapConcat`](#observable-flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),
and [`flatMap`](#observable-flatmap) is `flatMapWithConcurrencyLimit ∞` (all inputs are piped to output).

The [Function Construction rules](#function-construction-rules) below apply here.

<a name="observable-flatmapconcat"></a>
[`observable.flatMapConcat(f)`](#observable-flatmapconcat "observable.flatMapConcat(@ : Observable[A], f : A -> Observable[B] | Event[B] | B) : EventStream[B]") a [`flatMapWithConcurrencyLimit`](#observable-flatmapwithconcurrencylimit) with limit of 1.

The [Function Construction rules](#function-construction-rules) below apply here.

<a name="observable-scan"></a>
[`observable.scan(seed, f)`](#observable-scan "observable.scan(seed, f) : Property[A]") scans stream/property with given seed value and
accumulator function, resulting to a Property. For example, you might
use zero as seed and a "plus" function as the accumulator to create
an "integral" property. Instead of a function, you can also supply a
method name such as ".concat", in which case this method is called on
the accumulator value and the new stream value is used as argument.

Example:

```js
var plus = function (a,b) { return a + b }
Bacon.sequentially(1, [1,2,3]).scan(0, plus)
```

This would result to following elements in the result stream:

    seed value = 0
    0 + 1 = 1
    1 + 2 = 3
    3 + 3 = 6

When applied to a Property as in `r = p.scan(seed, f)`, there's a (hopefully insignificant) catch:
The starting value for `r` depends on whether `p` has an
initial value when scan is applied. If there's no initial value, this works
identically to EventStream.scan: the `seed` will be the initial value of
`r`. However, if `r` already has a current/initial value `x`, the
seed won't be output as is. Instead, the initial value of `r` will be `f(seed, x)`. This makes sense,
because there can only be 1 initial value for a Property at a time.

<a name="observable-fold"></a>
[`observable.fold(seed, f)`](#observable-fold "observable.fold(seed, f) : Property[A]") is like [`scan`](#observable-scan) but only emits the final
value, i.e. the value just before the observable ends. Returns a
[`Property`](#property).

<a name="observable-reduce"></a>
[`observable.reduce(seed, f)`](#observable-reduce "observable.reduce(seed,f)") synonym for [`fold`](#observable-fold).

<a name="observable-diff"></a>
[`observable.diff(start, f)`](#observable-diff "observable.diff(start, f)") returns a Property that represents the result of a comparison
between the previous and current value of the Observable. For the initial value of the Observable,
the previous value will be the given start.

Example:

```js
var distance = function (a,b) { return Math.abs(b - a) }
Bacon.sequentially(1, [1,2,3]).diff(0, distance)
```

This would result to following elements in the result stream:

    1 - 0 = 1
    2 - 1 = 1
    3 - 2 = 1

<a name="observable-zip"></a>
[`observable.zip(other [, f])`](#observable-zip "observable.zip(other [, f])") return an EventStream with elements
pair-wise lined up with events from this and the other EventStream or Property.
A zipped stream will publish only when it has a value from each
source and will only produce values up to when any single source ends.

The given function `f` is used to create the result value from value in the two
sources. If no function is given, the values are zipped into an array.

Be careful not to have too much "drift" between streams. If one stream
produces many more values than some other excessive buffering will
occur inside the zipped observable.

Example 1:

```js
var x = Bacon.fromArray([1, 2])
var y = Bacon.fromArray([3, 4])
x.zip(y, function(x, y) { return x + y })

# produces values 4, 6
```

See also [`zipWith`](#bacon-zipwith) and [`zipAsArray`](#bacon-zipasarray) for zipping more than 2 sources.

<a name="observable-slidingwindow"></a>
[`observable.slidingWindow(max [, min])`](#observable-slidingwindow "observable.slidingWindow(max[, min])") returns a Property that represents a
"sliding window" into the history of the values of the Observable. The
result Property will have a value that is an array containing the last `n`
values of the original observable, where `n` is at most the value of the
`max` argument, and at least the value of the `min` argument. If the
`min` argument is omitted, there's no lower limit of values.

For example, if you have a stream `s` with value a sequence 1 - 2 - 3 - 4 - 5, the
respective values in `s.slidingWindow(2)` would be [] - [1] - [1,2] -
[2,3] - [3,4] - [4,5]. The values of `s.slidingWindow(2,2)`would be
[1,2] - [2,3] - [3,4] - [4,5].

<a name="observable-log"></a>
[`observable.log()`](#observable-log "observable.log()") logs each value of the Observable to the console.
It optionally takes arguments to pass to console.log() alongside each
value. To assist with chaining, it returns the original Observable. Note
that as a side-effect, the observable will have a constant listener and
will not be garbage-collected. So, use this for debugging only and
remove from production code. For example:

```js
myStream.log("New event in myStream")
```

or just

```js
myStream.log()
```

<a name="observable-dolog"></a>
[`observable.doLog()`](#observable-dolog "observable.doLog()") logs each value of the Observable to the console. doLog() behaves like [`log`](#observable-log)
but does not subscribe to the event stream. You can think of doLog() as a
logger function that – unlike log() – is safe to use in production. doLog() is
safe, because it does not cause the same surprising side-effects as log()
does.

<a name="observable-combine"></a>
[`observable.combine(property2, f)`](#observable-combine "observable.combine(property2, f)") combines the latest values of the two
streams or properties using a two-arg function. Similarly to [`scan`](#observable-scan), you can use a
method name instead, so you could do `a.combine(b, ".concat")` for two
properties with array value. The result is a Property.

<a name="observable-withstatemachine"></a>
[`observable.withStateMachine(initState, f)`](#observable-withstatemachine "observable.withStateMachine(initState, f)") lets you run a state machine
on an observable. Give it an initial state object and a state
transformation function that processes each incoming event and
returns and array containing the next state and an array of output
events. Here's an an example, where we calculate the total sum of all
numbers in the stream and output the value on stream end:

```js
Bacon.fromArray([1,2,3])
  .withStateMachine(0, function(sum, event) {
    if (event.hasValue())
      return [sum + event.value(), []]
    else if (event.isEnd())
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```

<a name="observable-decode"></a>
[`observable.decode(mapping)`](#observable-decode "observable.decode(mapping)") decodes input using the given mapping. Is a
bit like a switch-case or the decode function in Oracle SQL. For
example, the following would map the value 1 into the string "mike"
and the value 2 into the value of the `who` property.

```js
property.decode({1 : "mike", 2 : who})
```

This is actually based on [`combineTemplate`](#bacon-combinetemplate) so you can compose static
and dynamic data quite freely, as in

```js
property.decode({1 : { type: "mike" }, 2 : { type: "other", whoThen : who }})
```

The return value of [`decode`](#observable-decode) is always a [`Property`](#property).

<a name="observable-awaiting"></a>
[`observable.awaiting(otherObservable)`](#observable-awaiting "observable.awaiting(otherObservable)") creates a Property that indicates whether
`observable` is awaiting `otherObservable`, i.e. has produced a value after the latest
value from `otherObservable`. This is handy for keeping track whether we are
currently awaiting an AJAX response:

```js
var showAjaxIndicator = ajaxRequest.awaiting(ajaxResponse)
```

<a name="observable-endonerror"></a>
[`observable.endOnError()`](#observable-endonerror "observable.endOnError()") ends the `Observable` on first [`Error`](#bacon-error) event. The
error is included in the output of the returned `Observable`.

<a name="observable-endonerror-f"></a>
[`observable.endOnError(f)`](#observable-endonerror-f "observable.endOnError(f)") ends the `Observable` on first [`Error`](#bacon-error) event for which
the given predicate function returns true. The error is included in the
output of the returned `Observable`. The [Function Construction rules](#function-construction-rules) apply, so
you can do for example `.endOnError(".serious")`.

<a name="observable-withhandler"></a>
[`observable.withHandler(f)`](#observable-withhandler "observable.withHandler(f)") lets you do more custom event handling: you
get all events to your function and you can output any number of events
and end the stream if you choose. For example, to send an error and end
the stream in case a value is below zero:

```js
if (event.hasValue() && event.value() < 0) {
  this.push(new Bacon.Error("Value below zero"));
  return this.push(end());
} else {
  return this.push(event);
}
```

Note that it's important to return the value from `this.push` so that
the connection to the underlying stream will be closed when no more
events are needed.

<a name="observable-name"></a>
[`observable.name(newName)`](#observable-name "observable.name(@ : Observable[A], newName : String) : Observable[A]") sets the name of the observable. Overrides the default
implementation of `toString` and `inspect`.
Returns itself.

<a name="observable-withdescription"></a>
[`observable.withDescription(param...)`](#observable-withdescription "observable.withDescription(@ : Observable[A], param...) : Observable[A]") Sets the structured description of the observable. The `toString` and `inspect` methods
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.toString())
    --> Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --> Bacon.once(1).times(-1)

<a name="observable-groupby"></a>
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
stream life. Stream transformed by `limitF` is passed on if provided. `limitF` gets grouped stream
and the original event causing the stream to start as parameters.

Calculator for grouped consecutive values until group is cancelled:

    var events = [
      {id: 1, type: "add", val: 3 },
      {id: 2, type: "add", val: -1 },
      {id: 1, type: "add", val: 2 },
      {id: 2, type: "cancel"},
      {id: 3, type: "add", val: 2 },
      {id: 3, type: "cancel"},
      {id: 1, type: "add", val: 1 },
      {id: 1, type: "add", val: 2 },
      {id: 1, type: "cancel"}
    ]

    function keyF(event) {
      return event.id
    }

    function limitF(groupedStream, groupStartingEvent) {
      var cancel = groupedStream.filter(function(x) { return x.type === "cancel"}).take(1)
      var adds = groupedStream.filter(function(x) { return x.type === "add" })
      return adds.takeUntil(cancel).map(".val")
    }

    Bacon.sequentially(2, events)
      .groupBy(keyF, limitF)
      .flatMap(function(groupedStream) {
        return groupedStream.fold(0, function(acc, x) { return acc + x })
      })
      .onValue(function(sum) {
        console.log(sum)
        // returns [-1, 2, 8] in an order
      })

EventStream
-----------

<a name="bacon-eventstream"></a>
[`Bacon.EventStream`](#bacon-eventstream "Bacon.EventStream") a stream of events. See methods below.

<a name="stream-concat"></a>
[`stream.concat(otherStream)`](#stream-concat "stream.concat(otherStream)") concatenates two streams into one stream so that
it will deliver events from `stream` until it ends and then deliver
events from `otherStream`. This means too that events from `stream2`,
occurring before the end of `stream` will not be included in the result
stream.

<a name="stream-merge"></a>
[`stream.merge(otherStream)`](#stream-merge "stream.merge(otherStream)") merges two streams into one stream that delivers events from both

<a name="stream-holdwhen"></a>
[`stream.holdWhen(valve)`](#stream-holdwhen "stream.holdWhen(@ : EventStream[A], valve : Observable[B]) : EventStream[A]") pauses and buffers the event stream if last event in valve is truthy.
All buffered events are released when valve becomes falsy.

<a name="stream-startwith"></a>
[`stream.startWith(value)`](#stream-startwith "stream.startWith(value)") adds a starting value to the stream, i.e. concats a
single-element stream contains [`value`](#event-value) with this stream.

<a name="stream-skipwhile"></a>
[`stream.skipWhile(f)`](#stream-skipwhile "stream.skipWhile(f)") skips elements until the given predicate function returns falsy once, and then
lets all events pass through.
The [Function Construction rules](#function-construction-rules) below apply here.

<a name="stream-skipwhile-property"></a>
[`stream.skipWhile(property)`](#stream-skipwhile-property "stream.skipWhile(property)") skips elements until the value of the given Property is falsy once, and then
lets all events pass through.

<a name="stream-skipuntil"></a>
[`stream.skipUntil(stream2)`](#stream-skipuntil "stream.skipUntil(stream2)") skips elements from `stream` until a Next event
appears in `stream2`. In other words, starts delivering values
from `stream` after first event appears in `stream2`.

<a name="stream-bufferwithtime"></a>
[`stream.bufferWithTime(delay)`](#stream-bufferwithtime "stream.bufferWithTime(delay)") buffers stream events with given delay.
The buffer is flushed at most once in the given delay. So, if your input
contains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]
and [5,6,7] respectively, given that the flush occurs between numbers 4 and 5.

<a name="stream-bufferwithtime-f"></a>
[`stream.bufferWithTime(f)`](#stream-bufferwithtime-f "stream.bufferWithTime(f)") works with a given "defer-function" instead
of a delay. Here's a simple example, which is equivalent to
stream.bufferWithTime(10):

```js
stream.bufferWithTime(function(f) { setTimeout(f, 10) })
```

<a name="stream-bufferwithcount"></a>
[`stream.bufferWithCount(count)`](#stream-bufferwithcount "stream.bufferWithCount(count)") buffers stream events with gi