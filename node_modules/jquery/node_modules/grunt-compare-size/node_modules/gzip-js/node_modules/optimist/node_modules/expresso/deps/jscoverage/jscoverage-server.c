/*
    jscoverage-server.c - JSCoverage server main routine
    Copyright (C) 2008 siliconforks.com

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <config.h>

#include <assert.h>
#include <ctype.h>
#include <signal.h>
#include <stdint.h>
#include <string.h>

#include <dirent.h>
#ifdef HAVE_PTHREAD_H
#include <pthread.h>
#endif

#include "encoding.h"
#include "global.h"
#include "http-server.h"
#include "instrument-js.h"
#include "resource-manager.h"
#include "stream.h"
#include "util.h"

static const char * specified_encoding = NULL;
const char * jscoverage_encoding = "ISO-8859-1";
bool jscoverage_highlight = true;

typedef struct SourceCache {
  char * url;
  uint16_t * characters;
  size_t num_characters;
  struct SourceCache * next;
} SourceCache;

static SourceCache * source_cache = NULL;

static const struct {
  const char * extension;
  const char * mime_type;
} mime_types[] = {
  {".gif", "image/gif"},
  {".jpg", "image/jpeg"},
  {".jpeg", "image/jpeg"},
  {".png", "image/png"},
  {".css", "text/css"},
  {".html", "text/html"},
  {".htm", "text/html"},
  {".js", "text/javascript"},
  {".txt", "text/plain"},
  {".xml", "application/xml"},
};

static bool verbose = false;
static const char * report_directory = "jscoverage-report";
static const char * document_root = ".";
static bool proxy = false;
static const char ** no_instrument;
static size_t num_no_instrument = 0;

#ifdef __MINGW32__
CRITICAL_SECTION javascript_mutex;
CRITICAL_SECTION source_cache_mutex;
#define LOCK EnterCriticalSection
#define UNLOCK LeaveCriticalSection
#else
pthread_mutex_t javascript_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t source_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
#define LOCK pthread_mutex_lock
#define UNLOCK pthread_mutex_unlock
#endif

static const SourceCache * find_cached_source(const char * url) {
  SourceCache * result = NULL;
  LOCK(&source_cache_mutex);
  for (SourceCache * p = source_cache; p != NULL; p = p->next) {
    if (strcmp(url, p->url) == 0) {
      result = p;
      break;
    }
  }
  UNLOCK(&source_cache_mutex);
  return result;
}

static void add_cached_source(const char * url, uint16_t * characters, size_t num_characters) {
  SourceCache * new_source_cache = xmalloc(sizeof(SourceCache));
  new_source_cache->url = xstrdup(url);
  new_source_cache->characters = characters;
  new_source_cache->num_characters = num_characters;
  LOCK(&source_cache_mutex);
  new_source_cache->next = source_cache;
  source_cache = new_source_cache;
  UNLOCK(&source_cache_mutex);
}

static int get(const char * url, uint16_t ** characters, size_t * num_characters) __attribute__((warn_unused_result));

static int get(const char * url, uint16_t ** characters, size_t * num_characters) {
  char * host = NULL;
  uint16_t port;
  char * abs_path = NULL;
  char * query = NULL;
  HTTPConnection * connection = NULL;
  HTTPExchange * exchange = NULL;
  Stream * stream = NULL;

  int result = URL_parse(url, &host, &port, &abs_path, &query);
  if (result != 0) {
    goto done;
  }

  connection = HTTPConnection_new_client(host, port);
  if (connection == NULL) {
    result = -1;
    goto done;
  }

  exchange = HTTPExchange_new(connection);
  HTTPExchange_set_request_uri(exchange, url);
  result = HTTPExchange_write_request_headers(exchange);
  if (result != 0) {
    goto done;
  }

  result = HTTPExchange_read_response_headers(exchange);
  if (result != 0) {
    goto done;
  }

  stream = Stream_new(0);
  result = HTTPExchange_read_entire_response_entity_body(exchange, stream);
  if (result != 0) {
    goto done;
  }
  char * encoding = HTTPMessage_get_charset(HTTPExchange_get_response_message(exchange));
  if (encoding == NULL) {
    encoding = xstrdup(jscoverage_encoding);
  }
  result = jscoverage_bytes_to_characters(encoding, stream->data, stream->length, characters, num_characters);
  free(encoding);
  if (result != 0) {
    goto done;
  }

  result = 0;

done:
  if (stream != NULL) {
    Stream_delete(stream);
  }
  if (exchange != NULL) {
    HTTPExchange_delete(exchange);
  }
  if (connection != NULL) {
    if (HTTPConnection_delete(connection) != 0) {
      HTTPServer_log_err("Warning: error closing connection after retrieving URL: %s\n", url);
    }
  }
  free(host);
  free(abs_path);
  free(query);
  return result;
}

static void send_response(HTTPExchange * exchange, uint16_t status_code, const char * html) {
  HTTPExchange_set_status_code(exchange, status_code);
  if (HTTPExchange_write_response(exchange, html, strlen(html)) != 0) {
    HTTPServer_log_err("Warning: error writing to client\n");
  }
}

/*
RFC 2396, Appendix A: we are checking for `pchar'
*/
static bool is_escaped(char c) {
  /* `pchar' */
  if (strchr(":@&=+$,", c) != NULL) {
    return false;
  }

  if (isalnum((unsigned char) c)) {
    return false;
  }

  /* `mark' */
  if (strchr("-_.!~*'()", c) != NULL) {
    return false;
  }

  return true;
}

static char * encode_uri_component(const char * s) {
  size_t length = 0;
  for (const char * p = s; *p != '\0'; p++) {
    if (is_escaped(*p)) {
      length = addst(length, 3);
    }
    else {
      length = addst(length, 1);
    }
  }

  length = addst(length, 1);
  char * result = xmalloc(length);
  size_t i = 0;
  for (const char * p = s; *p != '\0'; p++) {
    if (is_escaped(*p)) {
      result[i] = '%';
      i++;
      snprintf(result + i, 3, "%02X", *p);
      i += 2;
    }
    else {
      result[i] = *p;
      i++;
    }
  }
  result[i] = '\0';

  return result;
}

static unsigned int hex_value(char c) {
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
  else if ('A' <= c && c <= 'F') {
    return c - 'A' + 10;
  }
  else if ('a' <= c && c <= 'f') {
    return c - 'a' + 10;
  }
  else {
    return 0;
  }
}

static char * decode_uri_component(const char * s) {
  size_t length = strlen(s);
  char * result = xmalloc(length + 1);
  char * p = result;
  while (*s != '\0') {
    if (*s == '%') {
      if (s[1] == '\0' || s[2] == '\0') {
        *p = '\0';
        return result;
      }
      *p = hex_value(s[1]) * 16 + hex_value(s[2]);
      s += 2;
    }
    else {
      *p = *s;
    }
    p++;
    s++;
  }
  *p = '\0';
  return result;
}

static const char * get_entity(char c) {
  switch(c) {
  case '<':
    return "&lt;";
  case '>':
    return "&gt;";
  case '&':
    return "&amp;";
  case '\'':
    return "&apos;";
  case '"':
    return "&quot;";
  default:
    return NULL;
  }
}

static char * encode_html(const char * s) {
  size_t length = 0;
  for (const char * p = s; *p != '\0'; p++) {
    const char * entity = get_entity(*p);
    if (entity == NULL) {
      length = addst(length, 1);
    }
    else {
      length = addst(length, strlen(entity));
    }
  }

  length = addst(length, 1);
  char * result = xmalloc(length);
  size_t i = 0;
  for (const char * p = s; *p != '\0'; p++) {
    const char * entity = get_entity(*p);
    if (entity == NULL) {
      result[i] = *p;
      i++;
    }
    else {
      strcpy(result + i, entity);
      i += strlen(entity);
    }
  }
  result[i] = '\0';

  return result;
}

static const char * get_content_type(const char * path) {
  char * last_dot = strrchr(path, '.');
  if (last_dot == NULL) {
    return "application/octet-stream";
  }
  for (size_t i = 0; i < sizeof(mime_types) / sizeof(mime_types[0]); i++) {
    if (strcmp(last_dot, mime_types[i].extension) == 0) {
      return mime_types[i].mime_type;
    }
  }
  return "application/octet-stream";
}

/**
Checks whether a URI is on the no-instrument list.
@param  uri  the HTTP "Request-URI"; must not be NULL, and must not be a zero-length string
@return  true if the URI is on the no-instrument list, false otherwise
*/
static bool is_no_instrument(const char * uri) {
  assert(*uri != '\0');

  for (size_t i = 0; i < num_no_instrument; i++) {
    if (str_starts_with(uri, no_instrument[i])) {
      return true;
    }

    /*
    For a local URL, accept "/foo/bar" and "foo/bar" on the no-instrument list.
    */
    if (! proxy && str_starts_with(uri + 1, no_instrument[i])) {
      return true;
    }
  }

  return false;
}

static bool is_javascript(HTTPExchange * exchange) {
  const char * header = HTTPExchange_find_response_header(exchange, HTTP_CONTENT_TYPE);
  if (header == NULL) {
    /* guess based on extension */
    return str_ends_with(HTTPExchange_get_request_uri(exchange), ".js");
  }
  else {
    char * semicolon = strchr(header, ';');
    char * content_type;
    if (semicolon == NULL) {
      content_type = xstrdup(header);
    }
    else {
      content_type = xstrndup(header, semicolon - header);
    }
    /* RFC 4329 */
    bool result = strcmp(content_type, "text/javascript") == 0 ||
                  strcmp(content_type, "text/ecmascript") == 0 ||
                  strcmp(content_type, "text/javascript1.0") == 0 ||
                  strcmp(content_type, "text/javascript1.1") == 0 ||
                  strcmp(content_type, "text/javascript1.2") == 0 ||
                  strcmp(content_type, "text/javascript1.3") == 0 ||
                  strcmp(content_type, "text/javascript1.4") == 0 ||
                  strcmp(content_type, "text/javascript1.5") == 0 ||
                  strcmp(content_type, "text/jscript") == 0 ||
                  strcmp(content_type, "text/livescript") == 0 ||
                  strcmp(content_type, "text/x-javascript") == 0 ||
                  strcmp(content_type, "text/x-ecmascript") == 0 ||
                  strcmp(content_type, "application/x-javascript") == 0 ||
                  strcmp(content_type, "application/x-ecmascript") == 0 ||
                  strcmp(content_type, "application/javascript") == 0 ||
                  strcmp(content_type, "application/ecmascript") == 0;
    free(content_type);
    return result;
  }
}

static bool should_instrument_request(HTTPExchange * exchange) {
  if (! is_javascript(exchange)) {
    return false;
  }

  if (is_no_instrument(HTTPExchange_get_request_uri(exchange))) {
    return false;
  }

  return true;
}

static int merge(Coverage * coverage, FILE * f) __attribute__((warn_unused_result));

static int merge(Coverage * coverage, FILE * f) {
  Stream * stream = Stream_new(0);
  Stream_write_file_contents(stream, f);

  LOCK(&javascript_mutex);
  int result = jscoverage_parse_json(coverage, stream->data, stream->length);
  UNLOCK(&javascript_mutex);

  Stream_delete(stream);
  return result;
}

static void write_js_quoted_string(FILE * f, char * data, size_t length) {
  putc('"', f);
  for (size_t i = 0; i < length; i++) {
    char c = data[i];
    switch (c) {
    case '\b':
      fputs("\\b", f);
      break;
    case '\f':
      fputs("\\f", f);
      break;
    case '\n':
      fputs("\\n", f);
      break;
    case '\r':
      fputs("\\r", f);
      break;
    case '\t':
      fputs("\\t", f);
      break;
    /* IE doesn't support this */
    /*
    case '\v':
      fputs("\\v", f);
      break;
    */
    case '"':
      fputs("\\\"", f);
      break;
    case '\\':
      fputs("\\\\", f);
      break;
    default:
      putc(c, f);
      break;
    }
  }
  putc('"', f);
}

static void write_source(const char * id, const uint16_t * characters, size_t num_characters, FILE * f) {
  Stream * output = Stream_new(num_characters);
  jscoverage_write_source(id, characters, num_characters, output);
  fwrite(output->data, 1, output->length, f);
  Stream_delete(output);
}

static void write_json_for_file(const FileCoverage * file_coverage, int i, void * p) {
  FILE * f = p;

  if (i > 0) {
    putc(',', f);
  }

  write_js_quoted_string(f, file_coverage->id, strlen(file_coverage->id));

  fputs(":{\"coverage\":[", f);
  for (uint32_t i = 0; i < file_coverage->num_coverage_lines; i++) {
    if (i > 0) {
      putc(',', f);
    }
    int timesExecuted = file_coverage->coverage_lines[i];
    if (timesExecuted < 0) {
      fputs("null", f);
    }
    else {
      fprintf(f, "%d", timesExecuted);
    }
  }
  fputs("],\"source\":", f);
  if (file_coverage->source_lines == NULL) {
    if (proxy) {
      const SourceCache * cached = find_cached_source(file_coverage->id);
      if (cached == NULL) {
        uint16_t * characters;
        size_t num_characters;
        if (get(file_coverage->id, &characters, &num_characters) == 0) {
          write_source(file_coverage->id, characters, num_characters, f);
          add_cached_source(file_coverage->id, characters, num_characters);
        }
        else {
          fputs("[]", f);
          HTTPServer_log_err("Warning: cannot retrieve URL: %s\n", file_coverage->id);
        }
      }
      else {
        write_source(file_coverage->id, cached->characters, cached->num_characters, f);
      }
    }
    else {
      /* check that the path begins with / */
      if (file_coverage->id[0] == '/') {
        char * source_path = make_path(document_root, file_coverage->id + 1);
        FILE * source_file = fopen(source_path, "rb");
        free(source_path);
        if (source_file == NULL) {
          fputs("[]", f);
          HTTPServer_log_err("Warning: cannot open file: %s\n", file_coverage->id);
        }
        else {
          Stream * stream = Stream_new(0);
          Stream_write_file_contents(stream, source_file);
          fclose(source_file);
          uint16_t * characters;
          size_t num_characters;
          int result = jscoverage_bytes_to_characters(jscoverage_encoding, stream->data, stream->length, &characters, &num_characters);
          Stream_delete(stream);
          if (result == JSCOVERAGE_ERROR_ENCODING_NOT_SUPPORTED) {
            fputs("[]", f);
            HTTPServer_log_err("Warning: encoding %s not supported\n", jscoverage_encoding);
          }
          else if (result == JSCOVERAGE_ERROR_INVALID_BYTE_SEQUENCE) {
            fputs("[]", f);
            HTTPServer_log_err("Warning: error decoding %s in file %s\n", jscoverage_encoding, file_coverage->id);
          }
          else {
            write_source(file_coverage->id, characters, num_characters, f);
            free(characters);
          }
        }
      }
      else {
        /* path does not begin with / */
        fputs("[]", f);
        HTTPServer_log_err("Warning: invalid source path: %s\n", file_coverage->id);
      }
    }
  }
  else {
    fputc('[', f);
    for (uint32_t i = 0; i < file_coverage->num_source_lines; i++) {
      if (i > 0) {
        fputc(',', f);
      }
      char * source_line = file_coverage->source_lines[i];
      write_js_quoted_string(f, source_line, strlen(source_line));
    }
    fputc(']', f);
  }
  fputc('}', f);
}

static int write_json(Coverage * coverage, const char * path) __attribute__((warn_unused_result));

static int write_json(Coverage * coverage, const char * path) {
  /* write the JSON */
  FILE * f = fopen(path, "wb");
  if (f == NULL) {
    return -1;
  }
  putc('{', f);
  Coverage_foreach_file(coverage, write_json_for_file, f);
  putc('}', f);
  if (fclose(f) == EOF) {
    return -1;
  }
  return 0;
}

static void handle_jscoverage_request(HTTPExchange * exchange) {
  /* set the `Server' response-header (RFC 2616 14.38, 3.8) */
  HTTPExchange_set_response_header(exchange, HTTP_SERVER, "jscoverage-server/" VERSION);

  const char * abs_path = HTTPExchange_get_abs_path(exchange);
  assert(*abs_path != '\0');
  if (str_starts_with(abs_path, "/jscoverage-store")) {
    if (strcmp(HTTPExchange_get_method(exchange), "POST") != 0) {
      HTTPExchange_set_response_header(exchange, HTTP_ALLOW, "POST");
      send_response(exchange, 405, "Method not allowed\n");
      return;
    }

    Stream * json = Stream_new(0);

    /* read the POST body */
    if (HTTPExchange_read_entire_request_entity_body(exchange, json) != 0) {
      Stream_delete(json);
      send_response(exchange, 400, "Could not read request body\n");
      return;
    }

    Coverage * coverage = Coverage_new();
    LOCK(&javascript_mutex);
    int result = jscoverage_parse_json(coverage, json->data, json->length);
    UNLOCK(&javascript_mutex);
    Stream_delete(json);

    if (result != 0) {
      Coverage_delete(coverage);
      send_response(exchange, 400, "Could not parse coverage data\n");
      return;
    }

    mkdir_if_necessary(report_directory);
    char * current_report_directory;
    if (str_starts_with(abs_path, "/jscoverage-store/") && abs_path[18] != '\0') {
      char * dir = decode_uri_component(abs_path + 18);
      current_report_directory = make_path(report_directory, dir);
      free(dir);
    }
    else {
      current_report_directory = xstrdup(report_directory);
    }
    mkdir_if_necessary(current_report_directory);
    char * path = make_path(current_report_directory, "jscoverage.json");

    /* check if the JSON file exists */
    struct stat